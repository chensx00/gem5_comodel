//-------------------------------------------------------------------------
// ChecksumXcelRTL.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct XcelReqMsg__type__1__addr_5__data_32 Definition
typedef struct packed {
  logic [0:0] type_;
  logic [4:0] addr;
  logic [31:0] data;
} XcelReqMsg__type__1__addr_5__data_32;

// PyMTL BitStruct XcelRespMsg__type__1__data_32 Definition
typedef struct packed {
  logic [0:0] type_;
  logic [31:0] data;
} XcelRespMsg__type__1__data_32;

// PyMTL Component PipeQueue1EntryRTL Definition
// At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py

module PipeQueue1EntryRTL__EntryType_Bits128
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output logic [127:0] deq__ret  ,
  input logic [0:0] enq__en  ,
  input logic [127:0] enq__msg  ,
  output logic [0:0] enq__rdy  
);
  logic [127:0] entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py:490
  // s.deq.rdy //= lambda: s.full & ~s.reset
  
  always_comb begin : _lambda__s_checksum_unit_in_q_q_deq_rdy
    deq__rdy = full & ( ~reset );
  end

  // PyMTL Lambda Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py:489
  // s.enq.rdy //= lambda: ~s.reset & ( ~s.full | s.deq.en )
  
  always_comb begin : _lambda__s_checksum_unit_in_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ( ~full ) | deq__en );
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py:492
  // @update_ff
  // def ff_pipe1():
  //   s.full <<= ~s.reset & ( s.enq.en | s.full & ~s.deq.en )
  // 
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_pipe1
    full <= ( ~reset ) & ( enq__en | ( full & ( ~deq__en ) ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component PipeQueueRTL Definition
// At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py

module PipeQueueRTL__EntryType_Bits128__num_entries_1
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output logic [127:0] deq__ret  ,
  input logic [0:0] enq__en  ,
  input logic [127:0] enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  logic [127:0] q__deq__ret;
  logic [0:0] q__enq__en;
  logic [127:0] q__enq__msg;
  logic [0:0] q__enq__rdy;

  PipeQueue1EntryRTL__EntryType_Bits128 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component StepUnit Definition
// At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumRTL.py

module StepUnit_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input  logic [31:0] sum1_in ,
  output logic [31:0] sum1_out ,
  input  logic [31:0] sum2_in ,
  output logic [31:0] sum2_out ,
  input  logic [15:0] word_in 
);
  logic [31:0] __tmpvar__up_step_temp1;
  logic [31:0] __tmpvar__up_step_temp2;

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumRTL.py:38
  // @update
  // def up_step():
  //   temp1 = zext(s.word_in, 32) + s.sum1_in
  //   s.sum1_out @= temp1 & 0xffff
  // 
  //   temp2 = s.sum1_out + s.sum2_in
  //   s.sum2_out @= temp2 & 0xffff
  
  always_comb begin : up_step
    __tmpvar__up_step_temp1 = { { 16 { 1'b0 } }, word_in } + sum1_in;
    sum1_out = __tmpvar__up_step_temp1 & 32'd65535;
    __tmpvar__up_step_temp2 = sum1_out + sum2_in;
    sum2_out = __tmpvar__up_step_temp2 & 32'd65535;
  end

endmodule


// PyMTL Component ChecksumRTL Definition
// At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumRTL.py

module ChecksumRTL_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input logic [127:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [31:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  logic [31:0] sum1;
  logic [31:0] sum2;
  logic [15:0] words [0:7];
  //-------------------------------------------------------------
  // Component in_q
  //-------------------------------------------------------------

  logic [0:0] in_q__clk;
  logic [0:0] in_q__count;
  logic [0:0] in_q__reset;
  logic [0:0] in_q__deq__en;
  logic [0:0] in_q__deq__rdy;
  logic [127:0] in_q__deq__ret;
  logic [0:0] in_q__enq__en;
  logic [127:0] in_q__enq__msg;
  logic [0:0] in_q__enq__rdy;

  PipeQueueRTL__EntryType_Bits128__num_entries_1 in_q
  (
    .clk( in_q__clk ),
    .count( in_q__count ),
    .reset( in_q__reset ),
    .deq__en( in_q__deq__en ),
    .deq__rdy( in_q__deq__rdy ),
    .deq__ret( in_q__deq__ret ),
    .enq__en( in_q__enq__en ),
    .enq__msg( in_q__enq__msg ),
    .enq__rdy( in_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component steps[0:7]
  //-------------------------------------------------------------

  logic [0:0] steps__clk [0:7];
  logic [0:0] steps__reset [0:7];
  logic [31:0] steps__sum1_in [0:7];
  logic [31:0] steps__sum1_out [0:7];
  logic [31:0] steps__sum2_in [0:7];
  logic [31:0] steps__sum2_out [0:7];
  logic [15:0] steps__word_in [0:7];

  StepUnit_noparam steps__0
  (
    .clk( steps__clk[0] ),
    .reset( steps__reset[0] ),
    .sum1_in( steps__sum1_in[0] ),
    .sum1_out( steps__sum1_out[0] ),
    .sum2_in( steps__sum2_in[0] ),
    .sum2_out( steps__sum2_out[0] ),
    .word_in( steps__word_in[0] )
  );

  StepUnit_noparam steps__1
  (
    .clk( steps__clk[1] ),
    .reset( steps__reset[1] ),
    .sum1_in( steps__sum1_in[1] ),
    .sum1_out( steps__sum1_out[1] ),
    .sum2_in( steps__sum2_in[1] ),
    .sum2_out( steps__sum2_out[1] ),
    .word_in( steps__word_in[1] )
  );

  StepUnit_noparam steps__2
  (
    .clk( steps__clk[2] ),
    .reset( steps__reset[2] ),
    .sum1_in( steps__sum1_in[2] ),
    .sum1_out( steps__sum1_out[2] ),
    .sum2_in( steps__sum2_in[2] ),
    .sum2_out( steps__sum2_out[2] ),
    .word_in( steps__word_in[2] )
  );

  StepUnit_noparam steps__3
  (
    .clk( steps__clk[3] ),
    .reset( steps__reset[3] ),
    .sum1_in( steps__sum1_in[3] ),
    .sum1_out( steps__sum1_out[3] ),
    .sum2_in( steps__sum2_in[3] ),
    .sum2_out( steps__sum2_out[3] ),
    .word_in( steps__word_in[3] )
  );

  StepUnit_noparam steps__4
  (
    .clk( steps__clk[4] ),
    .reset( steps__reset[4] ),
    .sum1_in( steps__sum1_in[4] ),
    .sum1_out( steps__sum1_out[4] ),
    .sum2_in( steps__sum2_in[4] ),
    .sum2_out( steps__sum2_out[4] ),
    .word_in( steps__word_in[4] )
  );

  StepUnit_noparam steps__5
  (
    .clk( steps__clk[5] ),
    .reset( steps__reset[5] ),
    .sum1_in( steps__sum1_in[5] ),
    .sum1_out( steps__sum1_out[5] ),
    .sum2_in( steps__sum2_in[5] ),
    .sum2_out( steps__sum2_out[5] ),
    .word_in( steps__word_in[5] )
  );

  StepUnit_noparam steps__6
  (
    .clk( steps__clk[6] ),
    .reset( steps__reset[6] ),
    .sum1_in( steps__sum1_in[6] ),
    .sum1_out( steps__sum1_out[6] ),
    .sum2_in( steps__sum2_in[6] ),
    .sum2_out( steps__sum2_out[6] ),
    .word_in( steps__word_in[6] )
  );

  StepUnit_noparam steps__7
  (
    .clk( steps__clk[7] ),
    .reset( steps__reset[7] ),
    .sum1_in( steps__sum1_in[7] ),
    .sum1_out( steps__sum1_out[7] ),
    .sum2_in( steps__sum2_in[7] ),
    .sum2_out( steps__sum2_out[7] ),
    .word_in( steps__word_in[7] )
  );

  //-------------------------------------------------------------
  // End of component steps[0:7]
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__up_rtl_send_go;

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumRTL.py:93
  // @update
  // def up_rtl_send():
  //   go = s.in_q.deq.rdy & s.send.rdy
  //   s.send.en     @= go
  //   s.in_q.deq.en @= go
  
  always_comb begin : up_rtl_send
    __tmpvar__up_rtl_send_go = in_q__deq__rdy & send__rdy;
    send__en = __tmpvar__up_rtl_send_go;
    in_q__deq__en = __tmpvar__up_rtl_send_go;
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumRTL.py:99
  // @update
  // def up_rtl_sum():
  //   s.send.msg @= ( s.sum2 << 16 ) | s.sum1
  
  always_comb begin : up_rtl_sum
    send__msg = ( sum2 << 5'd16 ) | sum1;
  end

  assign in_q__clk = clk;
  assign in_q__reset = reset;
  assign steps__clk[0] = clk;
  assign steps__reset[0] = reset;
  assign steps__clk[1] = clk;
  assign steps__reset[1] = reset;
  assign steps__clk[2] = clk;
  assign steps__reset[2] = reset;
  assign steps__clk[3] = clk;
  assign steps__reset[3] = reset;
  assign steps__clk[4] = clk;
  assign steps__reset[4] = reset;
  assign steps__clk[5] = clk;
  assign steps__reset[5] = reset;
  assign steps__clk[6] = clk;
  assign steps__reset[6] = reset;
  assign steps__clk[7] = clk;
  assign steps__reset[7] = reset;
  assign in_q__enq__en = recv__en;
  assign in_q__enq__msg = recv__msg;
  assign recv__rdy = in_q__enq__rdy;
  assign words[0] = in_q__deq__ret[15:0];
  assign words[1] = in_q__deq__ret[31:16];
  assign words[2] = in_q__deq__ret[47:32];
  assign words[3] = in_q__deq__ret[63:48];
  assign words[4] = in_q__deq__ret[79:64];
  assign words[5] = in_q__deq__ret[95:80];
  assign words[6] = in_q__deq__ret[111:96];
  assign words[7] = in_q__deq__ret[127:112];
  assign steps__word_in[0] = words[0];
  assign steps__sum1_in[0] = 32'd0;
  assign steps__sum2_in[0] = 32'd0;
  assign steps__word_in[1] = words[1];
  assign steps__sum1_in[1] = steps__sum1_out[0];
  assign steps__sum2_in[1] = steps__sum2_out[0];
  assign steps__word_in[2] = words[2];
  assign steps__sum1_in[2] = steps__sum1_out[1];
  assign steps__sum2_in[2] = steps__sum2_out[1];
  assign steps__word_in[3] = words[3];
  assign steps__sum1_in[3] = steps__sum1_out[2];
  assign steps__sum2_in[3] = steps__sum2_out[2];
  assign steps__word_in[4] = words[4];
  assign steps__sum1_in[4] = steps__sum1_out[3];
  assign steps__sum2_in[4] = steps__sum2_out[3];
  assign steps__word_in[5] = words[5];
  assign steps__sum1_in[5] = steps__sum1_out[4];
  assign steps__sum2_in[5] = steps__sum2_out[4];
  assign steps__word_in[6] = words[6];
  assign steps__sum1_in[6] = steps__sum1_out[5];
  assign steps__sum2_in[6] = steps__sum2_out[5];
  assign steps__word_in[7] = words[7];
  assign steps__sum1_in[7] = steps__sum1_out[6];
  assign steps__sum2_in[7] = steps__sum2_out[6];
  assign sum1 = steps__sum1_out[7];
  assign sum2 = steps__sum2_out[7];

endmodule


// PyMTL Component NormalQueueCtrlRTL Definition
// At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py

module NormalQueueCtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] deq_en ,
  output logic [0:0] deq_rdy ,
  input  logic [0:0] enq_en ,
  output logic [0:0] enq_rdy ,
  output logic [0:0] raddr ,
  input  logic [0:0] reset ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  logic [0:0] deq_xfer;
  logic [0:0] enq_xfer;
  logic [0:0] head;
  logic [0:0] tail;

  // PyMTL Lambda Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py:84
  // s.deq_rdy //= lambda: ~s.reset & ( s.count > CountType(0) )
  
  always_comb begin : _lambda__s_in_q_ctrl_deq_rdy
    deq_rdy = ( ~reset ) & ( count > 2'd0 );
  end

  // PyMTL Lambda Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py:87
  // s.deq_xfer //= lambda: s.deq_en & s.deq_rdy
  
  always_comb begin : _lambda__s_in_q_ctrl_deq_xfer
    deq_xfer = deq_en & deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py:83
  // s.enq_rdy //= lambda: ~s.reset & ( s.count < s.num_entries )
  
  always_comb begin : _lambda__s_in_q_ctrl_enq_rdy
    enq_rdy = ( ~reset ) & ( count < 2'd2 );
  end

  // PyMTL Lambda Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py:86
  // s.enq_xfer //= lambda: s.enq_en & s.enq_rdy
  
  always_comb begin : _lambda__s_in_q_ctrl_enq_xfer
    enq_xfer = enq_en & enq_rdy;
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py:89
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= PtrType(0)
  //     s.tail  <<= PtrType(0)
  //     s.count <<= CountType(0)
  // 
  //   else:
  //     if s.deq_xfer:
  //       s.head <<= s.head + PtrType(1) if s.head < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer:
  //       s.tail <<= s.tail + PtrType(1) if s.tail < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer & ~s.deq_xfer:
  //       s.count <<= s.count + CountType(1)
  //     if ~s.enq_xfer & s.deq_xfer:
  //       s.count <<= s.count - CountType(1)
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( deq_xfer ) begin
        head <= ( head < 1'd1 ) ? head + 1'd1 : 1'd0;
      end
      if ( enq_xfer ) begin
        tail <= ( tail < 1'd1 ) ? tail + 1'd1 : 1'd0;
      end
      if ( enq_xfer & ( ~deq_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~enq_xfer ) & deq_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = enq_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_XcelReqMsg__type__1__addr_5__data_32__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__11f946f1b1099326
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output XcelReqMsg__type__1__addr_5__data_32 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  XcelReqMsg__type__1__addr_5__data_32 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  XcelReqMsg__type__1__addr_5__data_32 regs [0:1];

  // PyMTL Update Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/basic_rtl/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_XcelReqMsg__type__1__addr_5__data_32__num_entries_2
// At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py

module NormalQueueDpathRTL__8e342899926022cb
(
  input  logic [0:0] clk ,
  output XcelReqMsg__type__1__addr_5__data_32 deq_ret ,
  input  XcelReqMsg__type__1__addr_5__data_32 enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  XcelReqMsg__type__1__addr_5__data_32 queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  XcelReqMsg__type__1__addr_5__data_32 queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__11f946f1b1099326 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_XcelReqMsg__type__1__addr_5__data_32__num_entries_2
// At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/queues/queues.py

module NormalQueueRTL__8e342899926022cb
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output XcelReqMsg__type__1__addr_5__data_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input XcelReqMsg__type__1__addr_5__data_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  XcelReqMsg__type__1__addr_5__data_32 dpath__deq_ret;
  XcelReqMsg__type__1__addr_5__data_32 dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__8e342899926022cb dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component Reg Definition
// At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/basic_rtl/registers.py

module Reg__Type_Bits32
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /home/csx/workland/py_venv/pymtl3/lib/python3.10/site-packages/pymtl3/stdlib/basic_rtl/registers.py:10
  // @update_ff
  // def up_reg():
  //   s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_reg
    out <= in_;
  end

endmodule


// PyMTL Component ChecksumXcelRTL Definition
// Full name: ChecksumXcelRTL_noparam
// At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumXcelRTL.py

typedef struct packed {
  logic [31:0] reg0;
  logic [31:0] reg1;
  logic [31:0] reg2;
  logic [31:0] reg3;
  logic [31:0] reg4;
  logic [31:0] reg5;
} Regfile;

module ChecksumXcelRTL
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] xcel__req__en ,
  input XcelReqMsg__type__1__addr_5__data_32 xcel__req__msg ,
  output logic [0:0] xcel__req__rdy ,
  output logic [0:0] xcel__resp__en ,
  output XcelRespMsg__type__1__data_32 xcel__resp__msg ,
  input logic [0:0] xcel__resp__rdy ,
  output XcelReqMsg__type__1__addr_5__data_32 deq__ret_,
  output XcelReqMsg__type__1__addr_5__data_32 enq__msg_,
  output logic [0:0]deq__ret_type_,
  output logic [4:0]deq__ret_addr,
  output logic [31:0]deq__ret_data,
  output logic [31:0] reg0,
  output logic [31:0] reg1,
  output logic [31:0] reg2,
  output logic [31:0] reg3,
  output logic [31:0] reg4,
  output logic [31:0] reg5,

  output  logic [0:0] checksum_unit__recv__en_out,
  output logic [127:0] checksum_unit__recv__msg_out,
  output logic [0:0] checksum_unit__recv__rdy_out,
  output logic [0:0] checksum_unit__send__en_out,
  output logic [31:0] checksum_unit__send__msg_out,
  output logic [0:0] checksum_unit__send__rdy_out

);
  logic [0:0] start_pulse;
  logic [1:0] state;
  logic [1:0] state_next;
  //-------------------------------------------------------------
  // Component checksum_unit
  //-------------------------------------------------------------

  logic [0:0] checksum_unit__clk;
  logic [0:0] checksum_unit__reset;
  logic [0:0] checksum_unit__recv__en;
  logic [127:0] checksum_unit__recv__msg;
  logic [0:0] checksum_unit__recv__rdy;
  logic [0:0] checksum_unit__send__en;
  logic [31:0] checksum_unit__send__msg;
  logic [0:0] checksum_unit__send__rdy;

  assign checksum_unit__recv__en_out = checksum_unit__recv__en;
  assign checksum_unit__recv__msg_out = checksum_unit__recv__msg;
  assign checksum_unit__recv__rdy_out = checksum_unit__recv__rdy;

  assign checksum_unit__send__en_out = checksum_unit__send__en;
  assign checksum_unit__send__msg_out = checksum_unit__send__msg;
  assign checksum_unit__send__rdy_out = checksum_unit__send__rdy;

  ChecksumRTL_noparam checksum_unit
  (
    .clk( checksum_unit__clk ),
    .reset( checksum_unit__reset ),
    .recv__en( checksum_unit__recv__en ),
    .recv__msg( checksum_unit__recv__msg ),
    .recv__rdy( checksum_unit__recv__rdy ),
    .send__en( checksum_unit__send__en ),
    .send__msg( checksum_unit__send__msg ),
    .send__rdy( checksum_unit__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component checksum_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_q
  //-------------------------------------------------------------

  logic [0:0] in_q__clk;
  logic [1:0] in_q__count;
  logic [0:0] in_q__reset;
  logic [0:0] in_q__deq__en;
  logic [0:0] in_q__deq__rdy;
  XcelReqMsg__type__1__addr_5__data_32 in_q__deq__ret;
  logic [0:0] in_q__enq__en;
  XcelReqMsg__type__1__addr_5__data_32 in_q__enq__msg;
  logic [0:0] in_q__enq__rdy;

  assign deq__ret_ = in_q__deq__ret;
  assign enq__msg_ = in_q__enq__msg;

  assign deq__ret_type_ = in_q__deq__ret.type_;
  assign deq__ret_addr = in_q__deq__ret.addr;
  assign deq__ret_data = in_q__deq__ret.data;

  NormalQueueRTL__8e342899926022cb in_q
  (
    .clk( in_q__clk ),
    .count( in_q__count ),
    .reset( in_q__reset ),
    .deq__en( in_q__deq__en ),
    .deq__rdy( in_q__deq__rdy ),
    .deq__ret( in_q__deq__ret ),
    .enq__en( in_q__enq__en ),
    .enq__msg( in_q__enq__msg ),
    .enq__rdy( in_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reg_file[0:5]
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk [0:5];
  logic [31:0] reg_file__in_ [0:5];
  logic [31:0] reg_file__out [0:5];
  logic [0:0] reg_file__reset [0:5];

  assign reg0 = reg_file__out[0];
  assign reg1 = reg_file__out[1];
  assign reg2 = reg_file__out[2];
  assign reg3 = reg_file__out[3];
  assign reg4 = reg_file__out[4];
  assign reg5 = reg_file__out[5];

  Reg__Type_Bits32 reg_file__0
  (
    .clk( reg_file__clk[0] ),
    .in_( reg_file__in_[0] ),
    .out( reg_file__out[0] ),
    .reset( reg_file__reset[0] )
  );

  Reg__Type_Bits32 reg_file__1
  (
    .clk( reg_file__clk[1] ),
    .in_( reg_file__in_[1] ),
    .out( reg_file__out[1] ),
    .reset( reg_file__reset[1] )
  );

  Reg__Type_Bits32 reg_file__2
  (
    .clk( reg_file__clk[2] ),
    .in_( reg_file__in_[2] ),
    .out( reg_file__out[2] ),
    .reset( reg_file__reset[2] )
  );

  Reg__Type_Bits32 reg_file__3
  (
    .clk( reg_file__clk[3] ),
    .in_( reg_file__in_[3] ),
    .out( reg_file__out[3] ),
    .reset( reg_file__reset[3] )
  );

  Reg__Type_Bits32 reg_file__4
  (
    .clk( reg_file__clk[4] ),
    .in_( reg_file__in_[4] ),
    .out( reg_file__out[4] ),
    .reset( reg_file__reset[4] )
  );

  Reg__Type_Bits32 reg_file__5
  (
    .clk( reg_file__clk[5] ),
    .in_( reg_file__in_[5] ),
    .out( reg_file__out[5] ),
    .reset( reg_file__reset[5] )
  );

  //-------------------------------------------------------------
  // End of component reg_file[0:5]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumXcelRTL.py:81
  // @update
  // def up_fsm_output():
  //   if s.state == s.XCFG:
  //     s.in_q.deq.en  @= s.in_q.deq.rdy
  //     s.xcel.resp.en @= s.in_q.deq.rdy
  //     s.checksum_unit.recv.en  @= s.start_pulse & s.checksum_unit.recv.rdy
  //     s.checksum_unit.send.rdy @= 1
  // 
  //   elif s.state == s.WAIT:
  //     s.in_q.deq.en  @= 0
  //     s.xcel.resp.en @= 0
  //     s.checksum_unit.recv.en  @= s.checksum_unit.recv.rdy
  //     s.checksum_unit.send.rdy @= 1
  // 
  //   else: # s.state == s.BUSY:
  //     s.in_q.deq.en  @= 0
  //     s.xcel.resp.en @= 0
  //     s.checksum_unit.recv.en  @= 0
  //     s.checksum_unit.send.rdy @= 1
  
  always_comb begin : up_fsm_output
    if ( state == 2'd0 ) begin
      in_q__deq__en = in_q__deq__rdy;
      xcel__resp__en = in_q__deq__rdy;
      checksum_unit__recv__en = start_pulse & checksum_unit__recv__rdy;
      checksum_unit__send__rdy = 1'd1;
    end
    else if ( state == 2'd1 ) begin
      in_q__deq__en = 1'd0;
      xcel__resp__en = 1'd0;
      checksum_unit__recv__en = checksum_unit__recv__rdy;
      checksum_unit__send__rdy = 1'd1;
    end
    else begin
      in_q__deq__en = 1'd0;
      xcel__resp__en = 1'd0;
      checksum_unit__recv__en = 1'd0;
      checksum_unit__send__rdy = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumXcelRTL.py:101
  // @update
  // def up_resp_msg():
  //   s.xcel.resp.msg.type_ @= s.in_q.deq.ret.type_
  //   s.xcel.resp.msg.data  @= 0
  //   if s.in_q.deq.ret.type_ == XcelMsgType.READ:
  //     s.xcel.resp.msg.data @= s.reg_file[ s.in_q.deq.ret.addr[0:3] ].out
  
  always_comb begin : up_resp_msg
    xcel__resp__msg.type_ = in_q__deq__ret.type_;
    xcel__resp__msg.data = 32'd0;
    if ( in_q__deq__ret.type_ == 1'd0 ) begin
      xcel__resp__msg.data = reg_file__out[in_q__deq__ret.addr[3'd2:3'd0]];
    end
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumXcelRTL.py:53
  // @update
  // def up_start_pulse():
  //   s.start_pulse @=   s.xcel.resp.en & \
  //                    ( s.in_q.deq.ret.type_ == XcelMsgType.WRITE ) & \
  //                    ( s.in_q.deq.ret.addr == 4 )
  
  always_comb begin : up_start_pulse
    start_pulse = ( xcel__resp__en & ( in_q__deq__ret.type_ == 1'd1 ) ) & ( in_q__deq__ret.addr == 5'd4 );
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumXcelRTL.py:59
  // @update
  // def up_state_next():
  //   if s.state == s.XCFG:
  //     s.state_next @= (
  //       s.WAIT if s.start_pulse & ~s.checksum_unit.recv.rdy else
  //       s.BUSY if s.start_pulse &  s.checksum_unit.recv.rdy else
  //       s.XCFG
  //     )
  // 
  //   elif s.state == s.WAIT:
  //     s.state_next @= s.BUSY if s.checksum_unit.recv.rdy else s.WAIT
  // 
  //   else: # s.state == s.BUSY
  //     s.state_next @= s.XCFG if s.checksum_unit.send.en else s.BUSY
  
  always_comb begin : up_state_next
    if ( state == 2'd0 ) begin
      state_next = ( start_pulse & ( ~checksum_unit__recv__rdy ) ) ? 2'd1 : ( start_pulse & checksum_unit__recv__rdy ) ? 2'd2 : 2'd0;
    end
    else if ( state == 2'd1 ) begin
      state_next = checksum_unit__recv__rdy ? 2'd2 : 2'd1;
    end
    else
      state_next = checksum_unit__send__en ? 2'd0 : 2'd2;
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumXcelRTL.py:108
  // @update
  // def up_wr_regfile():
  //   for i in range(6):
  //     s.reg_file[i].in_ @= s.reg_file[i].out
  // 
  //   if s.in_q.deq.en & (s.in_q.deq.ret.type_ == XcelMsgType.WRITE):
  //     for i in range(6):
  //       s.reg_file[i].in_ @= (
  //         s.in_q.deq.ret.data if b5(i) == s.in_q.deq.ret.addr else
  //         s.reg_file[i].out
  //       )
  // 
  //   if s.checksum_unit.send.en:
  //     s.reg_file[5].in_ @= s.checksum_unit.send.msg
  
  always_comb begin : up_wr_regfile
    for ( int unsigned i = 1'd0; i < 3'd6; i += 1'd1 )
      reg_file__in_[3'(i)] = reg_file__out[3'(i)];
    if ( in_q__deq__en & ( in_q__deq__ret.type_ == 1'd1 ) ) begin
      for ( int unsigned i = 1'd0; i < 3'd6; i += 1'd1 )
        reg_file__in_[3'(i)] = ( 5'( 3'(i) ) == in_q__deq__ret.addr ) ? in_q__deq__ret.data : reg_file__out[3'(i)];
    end
    if ( checksum_unit__send__en ) begin
      reg_file__in_[3'd5] = checksum_unit__send__msg;
    end
  end

  // PyMTL Update Block Source
  // At /home/csx/workland/pymtl3/examples/ex04_xcel/ChecksumXcelRTL.py:74
  // @update_ff
  // def up_state():
  //   if s.reset:
  //     s.state <<= s.XCFG
  //   else:
  //     s.state <<= s.state_next
  
  always_ff @(posedge clk) begin : up_state
    if ( reset ) begin
      state <= 2'd0;
    end
    else
      state <= state_next;
  end

  assign in_q__clk = clk;
  assign in_q__reset = reset;
  assign reg_file__clk[0] = clk;
  assign reg_file__reset[0] = reset;
  assign reg_file__clk[1] = clk;
  assign reg_file__reset[1] = reset;
  assign reg_file__clk[2] = clk;
  assign reg_file__reset[2] = reset;
  assign reg_file__clk[3] = clk;
  assign reg_file__reset[3] = reset;
  assign reg_file__clk[4] = clk;
  assign reg_file__reset[4] = reset;
  assign reg_file__clk[5] = clk;
  assign reg_file__reset[5] = reset;
  assign checksum_unit__clk = clk;
  assign checksum_unit__reset = reset;
  assign in_q__enq__en = xcel__req__en;
  assign in_q__enq__msg = xcel__req__msg;
  assign xcel__req__rdy = in_q__enq__rdy;
  assign checksum_unit__recv__msg[31:0] = reg_file__out[0];
  assign checksum_unit__recv__msg[63:32] = reg_file__out[1];
  assign checksum_unit__recv__msg[95:64] = reg_file__out[2];
  assign checksum_unit__recv__msg[127:96] = reg_file__out[3];

endmodule
